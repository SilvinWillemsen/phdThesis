\chapter{The Bow}\label{ch:bow}
The bow is a very interesting excitation mechanism from a simulation perspective.
The bow excites the resonator at hand with a force due to friction, which introduces a nonlinear element that is dependent on the relative velocity between the bow and the string. 
The string `sticks' to the bow after which it `slips' when the restoring force of the string is too great and overcomes the friction force. This `stick-slip' behaviour, first coined by Bowden and Leben in 1939 \cite{Bowden1939} causes the string to move in a characteristic triangular motion where the corner of the triangle moves back and forth along the string (see Figure \ref{fig:helmholtz}). Herman Helmholtz was the first to discover this behaviour, which later got named \textit{Helmholtz motion} in his honour \cite{Helmholtz1860}.\footnote{Also see \url{https://www.youtube.com/watch?v=6JeyiM0YNo4}}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[->,node distance=3cm,
        thick,main node/.style={circle,draw}, scale=0.96, every node/.style={scale=0.96}]
    
        \node[] (image) at (0,0) {\includegraphics[width=1\columnwidth]{figures/exciters/helmholtz.eps}};
    
        \draw[thick, ->] (-0.25,0.60) arc (110:430:0.6);
        
      \end{tikzpicture}
    \caption{Helmholtz motion. If the bow moves up on the left side of the string, the `Helmholtz corner' travels anti-clockwise. \label{fig:helmholtz}}
\end{figure}

The Helmholtz motion gives bowed string instruments, such as the violin and cello, their characteristic sound. \SWcomment[helmholtz output figure]

\subsubsection{Brief history of bowed-string simulation}
The first nonlinear systems in the context of musical instrument simulations, including the bowed string, were presented by McIntyre, et al. in 1983 \cite{McIntyre1983}. The first real-time implementation of the bowed string was due to Smith in 1986 and used digital waveguides for the string and a look-up table for the friction model \cite{Smith1986}. Simultaneously, Florens et al. presented a real-time implementation of the bowed string, but instead, the string was modelled using mass-spring systems and the friction model used a static friction model \cite{Florens1986} (see Section \ref{sec:staticFricMod}). One of the most complex friction models applied in a musical context to-date is the elasto-plastic friction model due to Dupont \cite{Dupont2002}, which Serafin et al. \cite{Serafin2003, Serafin2004} applied to a digital waveguide implementation of the string. 

The first appearance of FDTD methods in bowed string simulations was in a publication by Pitteroff and Woodhouse in \cite{Pitteroff1998}. Later, Maestre et al. in \cite{Maestre2014} used FDTD methods to implement a thermal friction model proposed by Woodhouse in \cite{Woodhouse2003}. In both cases, the string was implemented using digital waveguides. Desvages implemented a bowed string model using a static friction model and a two-polarisation FDTD model for the string in \cite{Desvages2016, Desvages2018}, but did not implement this in real-time. This chapter presents the first contribution of this dissertation published in papers \citeP[A] and \citeP[C]. Firstly, paper \citeP[A] shows the first real-time implementation of a bowed stiff string fully modelled using FDTD methods. Secondly, \citeP[C] presents the first (real-time) implementation of the elasto-plastic friction model applied to a FD scheme in a musical context.
\\

Before introducing various friction models, a brief introduction on interpolation and spreading operators will be given, which will be necessary to work with this type of excitation.

\section{Interpolation and spreading operators}\label{sec:interpolationSpreading}
As should be clear by now, FD schemes are an approximation to continuous space (and time) using a finite number of points. Working with the system between grid points is not impossible, but requires an extra step. If one would like to listen to a location between specified grid points, one can use interpolation. For this end, an \textit{interpolation operator} $I(x_\itxt)$ can be introduced and can be applied to a grid function \cite{theBible}. This operator is a function of $x_\itxt$, the (continuous) location of interest and can be defined in various levels of accuracy. Here, a 1D system $u(x,t)$ is assumed where $x\in \D$ for spatial domain $\D$.

An interpolation operator can be applied to a grid function $\uln$ and when expanded performs the following operation:
\begin{equation}
    I_{l,o}(x_i)u_l^n = \sum_{l\in d} I_{l,o}(x_i)\cdot u_l^n,
\end{equation} 
where $o$ is the order of the operator, and discrete domain $d$ needs to be the same for $I_{l,o}(x_\text{i})$ and $\uln$.
The simplest interpolation operator is of '0\textsuperscript{th}'-order and is defined as
\begin{equation}\label{eq:zerothOrderI}
    I_{l,0}(x_\itxt) = \begin{cases}
        1, & \text{if}\ l = l_\itxt,\\
        0, & \text{otherwise},
    \end{cases}
\end{equation}
where the grid location of interest is defined as $l_\itxt = \floor[x_\itxt / h]$ (see Figure \ref{fig:zerothOrderInterpol}). Instead of actually performing an interpolation operation, $I_0$ simply floors its input to the grid location below. 
%As an example, for a 1D system of length $L=1$ described by $u(x,t)$, the location of interest is at $x_\itxt = 0.25$. If the grid spacing $h = 0.2$ the grid point of interest will be $l_\itxt = \floor[0.25/0.2] = \floor[1.25] = 1$. Writing this in operator form yields
% \begin{equation*}
%     u(0.25, t)\approxeq I_{l,0}(0.25)\uln = u_1^n.
% \end{equation*}
%
% \input{exciters/interpolation.tex}
%
A slightly more accurate way to perform 0\thOrder interpolation is to \textit{round} $x_\itxt/h$ to the nearest neighbour, rather than using the flooring operation. 

First-order or linear interpolation also uses the fractional part of the flooring operation according to $\alpha_\itxt = x_\itxt / h - l_\itxt$ and is defined as
\begin{equation}\label{eq:firstOrderI}
    I_{l,1}(x_\itxt) = \begin{cases}
        (1-\alpha_\itxt), & \text{if}\ l = l_\itxt,\\
        \alpha_\itxt , & \text{if}\ l = l_\itxt + 1,\\
        0 & \text{otherwise.}
    \end{cases}
\end{equation}
See Figure \ref{fig:firstOrderInterpol}. 
% Using the same example as before, $\alpha = 1.25 - \floor[1.25] = 0.25$ and
% \begin{equation*}
%     u(0.25, t)\approxeq I_{l,1}(0.25)\uln = 0.75u_1^n + 0.25 u_2^n,
% \end{equation*}

The highest order interpolator used in this project is the Lagrange cubic interpolator: 
\begin{equation}\label{eq:cubicI}
    I_{l,3}(x_\itxt) = \begin{cases}
        -\alpha_\itxt (\alpha_\itxt-1)(\alpha_\itxt-2)/6, & l = l_\itxt-1,\\
        (\alpha_\itxt-1)(\alpha_\itxt+1)(\alpha_\itxt-2)/2,  & l = l_\itxt,\\
        -\alpha_\itxt (\alpha_\itxt+1)(\alpha_\itxt-2)/2, & l = l_\itxt + 1,\\
        \alpha_\itxt (\alpha_\itxt+1)(\alpha_\itxt-1)/6, & l = l_\itxt + 2,\\
        0, & \text{otherwise.}
    \end{cases}
\end{equation}
See Figure \ref{fig:cubicInterpol}. 
% Applied to a grid function using the same example as before, yields
% \begin{equation*}
%     u(0.25, t)\approxeq I_{l,3}(0.25)\uln = -0.0547u_0^n + 0.8203u_1^n + 0.2734u_2^n -0.0391 u_3^n.
% \end{equation*}
Notice that the sum of all values of $I(x_\itxt)$, regardless of the order of interpolation or the value of $\alpha_\itxt$, add up to $1$.

\def\figWidth{0.32}
\begin{figure}[b]
    \centering
    \subfloat[$0$\thOrder interpolation.\label{fig:zerothOrderInterpol}]{\includegraphics[width=\figWidth\textwidth]{figures/exciters/noInterpol2.pdf}}\hfill
    \subfloat[Linear interpolation.\label{fig:firstOrderInterpol}]{\includegraphics[width=\figWidth\textwidth]{figures/exciters/linearInterpol2.pdf}}\hfill
    \subfloat[Cubic interpolation.\label{fig:cubicInterpol}]{\includegraphics[width=\figWidth\textwidth]{figures/exciters/cubicInterpol2.pdf}}
    \caption{Interpolation with varying orders of accuracy.\label{fig:interpolation}}
\end{figure}

One could potentially create higher-order interpolation operators, but as one is restricted to a finite domain, the flexibility of the implementation will become less. Notice that if $\alpha_\itxt = 0$, the higher-order interpolators reduce to the $0$\thOrder one in Eq. \eqref{eq:zerothOrderI}.

Apart from interpolation operators, one may define \textit{spreading operators} which can be interpreted as an inverse interpolation operation. A spreading operator $J(x_\itxt)$ is used to interact with a distributed FD scheme in the form of an excitation or other interactions such as connections or collisions between multiple schemes (also see Part \ref{part:interactions}).

The spreading operators can be defined in the same way as the interpolation operators described above, yielding a $0$\thOrder spreading operator
\begin{equation}\label{eq:zerothOrderJ}
    J_{l,0}(x_\itxt) = \frac{1}{h}\begin{cases}
        1, & \text{if}\ l = l_\itxt,\\
        0, & \text{otherwise},
    \end{cases}
\end{equation}
a linear spreading operator
\begin{equation}\label{eq:firstOrderJ}
    J_{l,1}(x_\itxt) = \frac{1}{h}\begin{cases}
        (1-\alpha_\itxt), & \text{if}\ l = l_\itxt,\\
        \alpha_\itxt , & \text{if}\ l = l_\itxt + 1,\\
        0 & \text{otherwise,}
    \end{cases}
\end{equation}
and a Lagrange cubic spreading operator
\begin{equation}\label{eq:cubicJ}
    J_{l,3}(x_\itxt) = \frac{1}{h}\begin{cases}
        -\alpha_\itxt (\alpha_\itxt-1)(\alpha_\itxt-2)/6, & l = l_\itxt-1,\\
        (\alpha_\itxt-1)(\alpha_\itxt+1)(\alpha_\itxt-2)/2,  & l = l_\itxt,\\
        -\alpha_\itxt (\alpha_\itxt+1)(\alpha_\itxt-2)/2, & l = l_\itxt + 1,\\
        \alpha_\itxt (\alpha_\itxt+1)(\alpha_\itxt-1)/6, & l = l_\itxt + 2,\\
        0, & \text{otherwise.}
    \end{cases}
\end{equation}
Notice the scaling by $1/h$ which will be more elaborated on in Chapter \ref{ch:connections}. As is the case with the interpolation operators, higher-order spreading operators reduce to Eq. \eqref{eq:zerothOrderJ} if $\alpha_\itxt = 0$.

The spreading operators, $J(x_\itxt)$ approximate the spatial Dirac delta function $\delta(x-x_\itxt)$, a test function defined as
\begin{equation}\label{eq:spatialDirac}
    \delta(x)= \begin{cases}
        \infty, & x = 0,\\
        0, & \text{otherwise},
    \end{cases} \qaq \int_{-\infty}^{\infty} \delta(x)dx = 1,
\end{equation}
used in continuous time to locate an external force to a location $x_\itxt$ along a system distributed over space $x$. Note that the definition in \eqref{eq:spatialDirac} will not be used in practice. Instead, it can be approximated using the spreading operators presented in this section. 

The following identity is extremely useful when solving systems including interpolation and spreading operators of the same order $o$
\begin{equation}\label{eq:identityIJ}
    \langle f, J_o(x_\itxt) \rangle_d = I_o(x_\itxt) f,
\end{equation}
for any (grid) function $f$ and discrete domain $d$. From this, it follows that taking the norm of a spreading operator $J_o(x_\itxt)$ over a given domain is identical to applying to its `dual' interpolation operator (of the same order $o$ and same input $x_\itxt$):
\begin{equation}
    \langle  J_o(x_\itxt), J_o(x_\itxt)\rangle_d = \lVert J_o(x_\itxt)\rVert^2_d = I_o(x_\itxt)J_o(x_\itxt).
\end{equation}
See Section \ref{sec:innerProduct} for more details on the inner product and the norm.

\subsubsection{Other distributions}
This section presented interpolation and spreading operators that interact with the state of a FD scheme at a single location $x_\itxt$ and either interpolates or distributes over a range of points. Although multiple grid points might be used for these operations, the interpolation or spreading is not \textit{distributed}. Physical exciters such as mallets or bows have a non-zero width and thus interact with a larger part of the system. One could make an arbitrary distribution function $E$ with elements $e_l$ (in 1D) where $l\in d$ for discrete domain $d$ of the system at hand. The \textit{distribution} and spreading operators become
\begin{equation}
    I_l = \frac{e_l}{\sum_d e_l} \qaq J_l = \frac{1}{h}I_l.
\end{equation}
Although any values for $E$ would work, to retain correct scaling, the sum of $E$ needs to be normalised to $1$ as shown above.

\section{The Newton-Raphson method}\label{sec:newtonRaphson}
Before moving on to more complex nonlinear excitation mechanisms, it is useful to go over the process of how to solve some of these mechanisms using an iterative root-finding method called the \textit{Newton-Raphson} method (or Newton-Raphson for short). 

If a FD scheme not be solved explicitly, due to a nonlinear dependence on a variable for example, Newton-Raphson can be used. For a continuous and differentiable function $f(x) = 0$ its root can be approached using the following iteration
\begin{equation}\label{eq:newtonRaphson}
    x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}\ ,
\end{equation}
with iteration number $i$ and the tick is used to denote a derivation with respect to $x$.
This iteration will then be carried out until the difference between the values of two consecutive iterations is smaller than a given threshold:
\begin{equation}\label{eq:NRthreshold}
    |x_{i+1} - x_i| < \epsilon,
\end{equation} 
where $\epsilon$ is small, but its exact value depends on the situation at hand. To prevent Newton's method from iterating endlessly (which can happen in some cases), one can put a cap on the number of iterations allowed. 

Preferably, the starting point of the iteration, $x_0$, should be close to the value of where the root is expected to be. This is especially the case for a higher-ordered function with multiple roots (non-uniqueness) or many local variations. 

Algorithm \ref{alg:NR} shows an example of an implementation of Newton-Raphson using $f(x) = e^x -1\ \Rightarrow\ f'(x) = e^x $ and Figure \ref{fig:NR} visualises the iterative algorithm.
\\
\setlstMAT
\begin{lstlisting}[caption={Example of an implementation of the Newton-Raphson method using $f(x) = e^{x} - 1$.}, label=alg:NR]
% An example of the Newton Raphson method using f(x) = exp(x) - 1

x = 1;          % starting point
eps = 1e-4;     % threshold

% if the threshold has not been crossed before this number of 
% iterations, do not iterate more
maxIterations = 100;    
    
% loop until a maximum number of iterations
for i = 1:maxIterations

    % calculate next iteration (Eq. %*\eqrefMatlab[eq:newtonRaphson]*)
    xNext = x - (exp(x) - 1) / (exp(x));

    % threshold check (Eq. %*\eqrefMatlab[eq:NRthreshold]*)
    if abs(xNext - x) < eps 
        break; % break out of the for loop
    end

    % update the value of x
    x = xNext;
end
disp("The root of f(x) is at x = " + xNext)
\end{lstlisting}

\captionsetup[subfigure]{labelformat=empty}
\def\figWidth{0.30}
\begin{figure}[h]
    \centering
    \subfloat[]{\includegraphics[width=\figWidth\textwidth]{figures/exciters/NR1.eps}}\hfill
    \subfloat[]{\includegraphics[width=\figWidth\textwidth]{figures/exciters/NR2.eps}}\hfill
    \subfloat[]{\includegraphics[width=\figWidth\textwidth]{figures/exciters/NR3.eps}}
    \vspace{-2em}\caption{The Newton-Raphson method. The $x$-value of the root of the tangent line at $f(x_i)$ is used to evaluate the next iteration.\label{fig:NR}}
\end{figure}
\captionsetup[subfigure]{labelformat=parens}

\subsection{Multivariate Newton-Raphson}\label{sec:multivariateNR}
For $M$ functions $f_m$ dependent on the same number of independent variables $x_m$ with $m = \{1, \hdots, M\}$,  Newton-Raphson can be extended to the following \SWcomment[citation?]:
\begin{equation}\label{eq:multivariateNR}
    \mathbf{x}_{i+1} = 
    \mathbf{x}_i - 
    {\underbrace{\begin{bmatrix}
        \frac{\partial f_1(\mathbf{x}_i)}{\partial x_1} & \hdots & \frac{\partial f_1(\mathbf{x}_i)}{\partial x_M}\\
        \vdots & \ddots & \vdots\\
        \frac{\partial f_M(\mathbf{x}_i)}{\partial x_1} & \hdots & \frac{\partial f_M(\mathbf{x}_i)}{\partial x_M}
    \end{bmatrix}}_{\mathbf{J}(\mathbf{x})}}^{-1}
    \begin{bmatrix}
        f_1(\mathbf{x}_i)\\
        \vdots\\
        f_M(\mathbf{x}_i)
    \end{bmatrix},
\end{equation}
where the independent variables are collected in a column vector
\begin{equation}
    \mathbf{x} = \begin{bmatrix}
        x_1\\
        \vdots\\
        x_M
    \end{bmatrix},
\end{equation}
and the iteration number is again denoted by $i$.
The matrix in Eq. \eqref{eq:multivariateNR} is referred to as the \textit{Jacobian matrix} $\mathbf{J}$ and contains the derivatives of all functions with respect to each individual independent variable. 

As an example, consider the following system of equations\footnote{Taken from \url{http://fourier.eng.hmc.edu/e176/lectures/NM/node21.html}}:
\begin{subequations}
    \begin{align}
        f_1(\mathbf{x}) &= 3 x_1 - \cos(x_2x_3) - 3/2 = 0,\\
        f_2(\mathbf{x}) &= 4x_1^2 - 625 x_2^2 + 2x_3-1 = 0,\\
        f_3(\mathbf{x}) &= 20 x_3 + e^{-x_1x_2}+9 = 0.
    \end{align} 
\end{subequations}
The Jacobian matrix will be 
\begin{equation*}
    \mathbf{J}(\mathbf{x}) = \begin{bmatrix}
        3 & x_3 \sin (x_2x_3) & x_2 \sin(x_2x_3)\\
        8x_1 & -1250 x_2 & 2\\
        -x_2e^{-x_1x_2} & -x_1e^{-x_1x_2} & 20
    \end{bmatrix},
\end{equation*}
and its roots can be found by iteratively calculating Eq. \eqref{eq:multivariateNR}.

\section{Static friction models}\label{sec:staticFricMod}
A friction model is a nonlinear function that is (at least) dependent on the relative velocity $\vrel$ between the bow and the string. This function scales how much the bow force affects the bowed object. 
In static friction models, the friction force is defined as a function of this relative velocity only.
The first mathematical description of friction was proposed by Coulomb in 1773 \cite{Coulomb1773}\todo{check references here} to which static friction, or \textit{stiction}, was added by Morin in 1833 \cite{Morin1833} and viscous friction, or velocity-dependent friction, by Reynolds in 1886 \cite{Reynolds1886}. In 1902, Stribeck found a smooth transition between the static and the coulomb part of the friction curve now referred to as the Stribeck effect \cite{Stribeck1902}. The latter is still the standard for static friction models today.

In this project, only the following static friction model has been used \cite{theBible}
\begin{equation}\label{eq:staticFriction}
    \Phi (\vrel) = \sqrt{2a}\vrel e^{-a\vrel^2 + 1/2}.
\end{equation}
See Figure \ref{fig:frictionCharacteristic}. Consider a string, its transverse displacement described by $u(x,t)$ defined for $x\in \D$ (see Chapter \ref{ch:stiffString}). The relative velocity between the string at bow position $x_\Btxt = x_\Btxt(t) \in \D$ and the bow is described as
\begin{equation}\label{eq:vrel}
    \vrel = \pt u(x_\Btxt, t) - v_\Btxt(t)
\end{equation}
(in m/s) with bow velocity $v_\Btxt = v_\Btxt(t)$ (in m/s).

\todo{FULL DOC SWEEP: check figure centering}\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/exciters/frictionCharacteristic.eps}
    \caption{The friction model in \eqref{eq:staticFriction} with $a = 100$. \label{fig:frictionCharacteristic}}
\end{figure}

Many of the friction models contain a discontinuity where the relative velocity $\vrel = 0$ due to a multiplication with $\sgn(\vrel)$ in their definition. Equation \eqref{eq:staticFriction} approximates discontinuous bow models using a continuous and differentiable function. This makes it easier to work with when trying to implement the system as will be explained next.

\subsection{The bowed stiff string}
Recalling the PDE of the stiff string in Eq. \eqref{eq:stiffStringPDE}
\begin{equation}
    \rho A \ptt u = T \pxx u - EI \pxxxx u - 2 \sz \rho A \pt u + 2 \so \rho A\pt \pxx u,
\end{equation}
one can add the bow force to the equation according to 
\begin{equation}\label{eq:bowedStiffStringPDE}
    \rho A \ptt u = T \pxx u - EI \pxxxx u - 2 \sz \rho A \pt u + 2 \so \rho A\pt \pxx u - \delta(x-x_\Btxt)f_\Btxt\Phi(\vrel)
\end{equation}
where spatial Dirac delta function $\delta(x-x_\Btxt)$ (in m$^{-1}$) (see Section \ref{sec:interpolationSpreading}) positions the bow along the string and $f_\Btxt = f_\Btxt(t) \geq 0$ is the bow force (in N).\footnote{If the spatial Dirac delta function were omitted, the bow force would be applied to the entire string domain rather than only the bow location $x_\text{B}$.} 

\subsubsection{Intuition}
From Eq. \eqref{eq:bowedStiffStringPDE} it can be seen that the bow force gets scaled by the friction model $\Phi(\vrel)$ shown in Figure \ref{fig:frictionCharacteristic}. 
The figure shows that if $\vrel$ is too large (either positively or negatively) the bow term in \eqref{eq:bowedStiffStringPDE} becomes $0$. If, on the other hand, $\vrel$ is closer to $0$, the bow will have an effect on the string. This can be interpreted in terms of static and dynamic friction\footnote{`Static' and `dynamic' friction are unrelated to `static' and `dynamic' friction models.}. A stationary object requires more force to be moved than a moving object, i.e., the static friction coefficient is always higher than the dynamic friction coefficient. This is essentially what the friction model tries to simulate.

\subsubsection{Discrete time}
Dividing all terms in Eq. \eqref{eq:bowedStiffStringFDS} by $\rho A$ and discretising the system yields
%
\begin{equation}\label{eq:bowedStiffStringFDS}
    \dtt \uln = c^2 \dxx \uln - \kappa^2 \dxxxx \uln - 2 \sz \dtd \uln + 2 \so\dtm\dxx \uln - J_l(x_\Btxt^n)F_\Btxt^n\Phi(\vrel^n),
\end{equation}
with $F_\Btxt^n = f_\Btxt^n/\rho A$ and spreading operator $J_l(x_\Btxt)$ (in m$^{-1}$) as described in Section \ref{sec:interpolationSpreading}, the order of which remains undetermined for now. Notice that, as the bow position, bow velocity and bow force are time-dependent, these have received a superscript $n$. These parameters are called control parameters and will be supplied by the performer in the eventual implementation.

The relative velocity in Eq. \eqref{eq:vrel} is discretised using a centred difference operator according to
\begin{equation}\label{eq:vrelDisc}
    \vrel^n = I_l(x_\Btxt^n)\dtd \uln - v_\Btxt^n.
\end{equation}
The main issue with Eq. \eqref{eq:vrelDisc} is that, due to the centred difference operator, the FD scheme is now nonlinearly dependent on $u_l^{n+1}$. To solve Eq. \eqref{eq:bowedStiffStringFDS}, an iterative solver is required, such as Newton-Raphson described in Section \ref{sec:newtonRaphson}. This process could be circumvented by using a backward  difference operator in Eq. \eqref{eq:vrelDisc}, but this will affect accuracy of the bow model.

\subsubsection{Solution}
To find a solution for $u_l^{n+1}$ at the bow location, an inner product of the scheme in Eq. \eqref{eq:bowedStiffStringFDS} with spreading operator $J_l(x_\Btxt^n)$ must be taken over the discrete domain of the string $d$ which isolates the scheme at the bowing location. Performing this operation and using identity \eqref{eq:identityIJ} yields
\begin{equation}\label{eq:bowLocFDS}
    \begin{aligned}
    I_l(x_\Btxt^n)\dtt\uln =\ &c^2 I_l(x_\Btxt^n)\dxx \uln - \kappa^2 I_l(x_\Btxt^n)\dxxxx \uln- 2 \sz I_l(x_\Btxt^n)\dtd \uln\\
    & + 2 \so I_l(x_\Btxt^n)\dtm\dxx \uln - \lVert J_l(x_\Btxt^n)\rVert^2_d F_\Btxt^n\Phi(\vrel^n).
    \end{aligned}
\end{equation}
One can rewrite Eq. \eqref{eq:vrelDisc} to 
\begin{equation}\label{eq:vrelRewritten}
   I_l(x_\Btxt^n)\dtd \uln =  \vrel^n + v_\Btxt^n,
\end{equation}
and using identity \eqref{eq:identity1}, Eq. \eqref{eq:bowLocFDS} can be rewritten and assigned to a function $g(\vrel^n)$ 
\begin{equation}\label{eq:staticFrictionNRfunc}
    g(\vrel^n) = \left(\frac{2}{k} + 2\sz\right)\vrel^n + \lVert J_l(x_\Btxt^n)\rVert^2_d F_\Btxt^n\Phi(\vrel^n) + b^n = 0,
\end{equation}
% Here, $b$ contains all terms not dependent on $\vrel$. As the operators can be interchanged, i.e., the order of application does not matter, could write $b$ according to
where the terms not dependent on $\vrel$ are collected in
\begin{align*}
    b^n =\ &-\frac{2}{k}I_l(x_\Btxt^n)\dtm \uln-c^2 I_l(x_\Btxt^n)\dxx \uln + \kappa^2 I_l(x_\Btxt^n)\dxxxx \uln \\
    &+ \left( \frac{2}{k} + 2 \sz \right)v_\Btxt^n - 2 \so I_l(x_\Btxt^n)\dtm\dxx \uln.
    % b =&\ \left(-\frac{2}{k}\dtm -c^2 \dxx+ \kappa^2\dxxxx - 2 \so \dtm\dxx\right) I(x_\Btxt^n)\uln + \left( \frac{2}{k} + 2 \sz \right)v_\Btxt^n.
\end{align*}
%
One can then perform the Newton-Raphson method detailed in Section \ref{sec:newtonRaphson} to iteratively solve for $\vrel$ 
%
\begin{equation}
    (\vrel^n)_{i+1} = (\vrel^n)_i - \frac{g\left((\vrel^n)_i\right)}{g'\left((\vrel^n)_i\right)}\ ,
\end{equation}
where
\begin{equation}
    g'(\vrel^n) = \frac{2}{k} + 2\sz + \lVert J_l(x_\Btxt^n)\rVert^2_\D F_\Btxt^n\Phi'(\vrel^n),
\end{equation}
and 
\begin{equation*}
    \begin{aligned}
        \Phi'(\vrel^n) %&= \sqrt{2a}e^{-a(\vrel^n)^2 + 1/2} + \sqrt{2a}\vrel^n * (-2a\vrel^n)e^{-a(\vrel^n)^2 + 1/2}\\
        %&
        = \sqrt{2a}\left(1 - 2a(\vrel^n)^2\right)e^{-a(\vrel^n)^2+1/2}.
    \end{aligned}
\end{equation*}
\subsubsection{Implementation}
\SWcomment[still need to write this bit]
The Newton-Raphson iteration needs to be performed for every sample\\

$\epsilon = 10^{-4}$\\
Limit of iterations is set to $100$

\begin{equation}
    I_l(x_\Btxt^n) \dxx \uln = (1-\alpha)\dxx u_{l_\Btxt}^n + \alpha \dxx u_{l_\Btxt+1}^n
\end{equation}

\subsection{Energy analysis}
Following the energy analysis of the stiff string presented in Section \eqref{sec:energyAnalysisString}, taking an inner product of Eq. \eqref{eq:bowedStiffStringFDS} (after multiplication by $\rho A$) with $(\dtd \uln)$ over discrete domain $d$ one arrives at the following 
\begin{align*}
    \dtp \h + \q &=  - \langle (\dtd \uln), J_l(x_\Btxt^n)f_\Btxt^n\Phi(\vrel^n) \rangle_d\\[-5pt]
    \xLeftrightarrow{\mystrut\ \text{Eq. \eqref{eq:identityIJ}}\ }\qquad &= -I_l(x_\Btxt^n)(\dtd \uln) f_\Btxt^n \Phi(\vrel^n) \\[-5pt]
    \xLeftrightarrow{\mystrut\ \text{Eq. \eqref{eq:vrelRewritten}}\ } \qquad &= \underbrace{-f_\Btxt^n \Phi(\vrel^n) \vrel^n}_{\text{loss}} - \underbrace{f_\Btxt^n \Phi(\vrel^n)v_\Btxt^n}_{\text{power}},
\end{align*}
where $\h$ and $\q$ are as defined in Eqs. \eqref{eq:energyBalanceStiffString} and \eqref{eq:dampingTermStiffString} respectively. As $\sgn\left(\Phi(\vrel^n)\right) = \sgn\left(\vrel^n\right)$ through Eq \eqref{eq:staticFriction}, one can observe that the first term on the right-hand side always has a negative effect on the rate of change of the total energy. This term can therefore be interpreted as the loss of power through the bow (as indicated). The last term is of indeterminate sign and can thus be interpreted as the power supplied by the bow. 

The final energy balance can thus be written as
\begin{equation}\label{eq:energyBalanceBow}
    \dtp \h = -\q - \q_\text{B} - \p 
\end{equation}
where 
\begin{equation*}
    \q_\text{B} = f_\Btxt^n \Phi(\vrel^n) \vrel^n \qaq \p = f_\Btxt^n \Phi(\vrel^n)v_\Btxt^n.
\end{equation*}

\section{Dynamic friction models}
As opposed to less complex static friction models, dynamic friction models relate the relative velocity to the friction force using a differential equation. Dynamic friction models exhibit a phenomenon called \textit{hysteresis}, which is the dependence of a system on its history. 

The first dynamic friction model was due to Dahl \cite{Dahl1968} and captured hysteresis effects. The Stribeck effect was, however, not taken into account. The LuGre model (named after the collaboration between Lund and Grenoble) was then proposed by Canudas de Wit et al. in \cite{Canudas1993, Canudas1995} and extended the Dahl model to take the Stribeck effect into account. The model assumes a large ensemble of bristles between the two sliding surfaces, each of which contributes a tiny amount to the total friction force. The drawback of this model is that it exhibits drift for extremely small external forces. In \cite{Dupont2002}, Dupont et al. extended the LuGre model by allowing for a purely elastic regime that solves the drift issue. This model is referred to as the \textit{elasto-plastic} friction model and is used in this project.

\subsection{The elasto-plastic friction model}
In a musical context, the elasto-plastic friction has been investigated in-depth by Serafin et al. in \cite{Serafin2003, Serafin2004, Avanzini2005}. Like the LuGre model, the elasto-plastic friction model assumes that the friction between the bow and the string is caused by a large quantity of bristles, all contributing a fraction of the total amount of friction. See Figure \ref{fig:elastoPlastic}.

\input{exciters/elastoPlasticFig.tex}

Unless denoted otherwise, this section follows the original model by Dupont et al. in \cite{Dupont2002}, but with the appropriate corrections added as presented in paper \citeP[C]. As opposed to the static friction model described in the previous section, the friction force $f$ (in N) is now dependent on the average bristle displacement $z = z(t)$ (in m) on top of the relative velocity $v = v(t)$ (in m/s). The force is defined as
\begin{equation}\label{eq:elastoPlasticForce}
    f(v, z) = s_0z + s_1\dot z + s_2v + s_3w,
\end{equation}
with bristle stiffness $s_0 \geq 0$ (in N/m), bristle damping $s_1 \geq 0$ (in kg/s), viscous friction $s_2 \geq 0$ (in kg/s) and, as presented in \cite{Serafin2004}, a dimensionless noise coefficient $s_3$ multiplied onto a pseudorandom function $w = w(t)$ (in N) generating values between $-1$ and $1$. Moreover, for a string defined over domain $\D$, the relative velocity between the string at bowing location $x_\Btxt = x_\Btxt(t) \in \D$ and the bow is (similar to Eq. \eqref{eq:vrel})
\begin{equation}\label{eq:vrelElasto}
    v = \pt u(x_\Btxt,t) - v_\Btxt,
\end{equation}
with bow velocity $v_\Btxt = v_\Btxt(t)$ (in m/s). Lastly, $\dot z$ is the rate of change of the bristle displacement (in m/s) and is related to $v$ according to
\begin{equation}\label{eq:zdot}
    \dot z = r(v, z) = v \bigg[ 1-  \alpha(v, z)\frac{z}{z_\text{ss}(v)}\bigg].
\end{equation}
Here, $z_\text{ss}$ is the steady-state function
\begin{equation}\label{eq:zss}
    z_\text{ss}(v) = \frac{\sgn(v)}{s_0}\left[f_\text{C}+(f_\text{S}-f_\text{C})e^{-(v/v_\text{S})^2}\right],
\end{equation}
where the $v_\text{S}$ is the Stribeck velocity (in m/s). Furthermore, using the normal force $f_\text{N} = f_\text{N}(t)$ (in N), the Coulomb force and stiction force can be calculated according to $f_\text{C} = f_\text{N}\mu_\text{C}$ and $f_\text{S} = f_\text{N}\mu_\text{S}$ respectively (both in N). In these definitions $\mu_\text{C}$ and $\mu_\text{S}$ are the dimensionless dynamic and static friction coefficients respectively. A plot of the steady state function can be found in Figure \ref{fig:zss}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/exciters/steadyState.eps}
    \caption{\label{fig:zss}The steady-state function $z_\text{ss}(v)$ plotted against relative velocity $v$ with $s_0 = 10^4$, $\mu_\text{C} = 0.3$, $\mu_\text{S} = 0.8$, $v_\text{S} = 0.1$ and $f_\text{N} = 5$.}
\end{figure}

Finally, $\alpha(v,z)$ in Eq. \eqref{eq:zdot} is an adhesion map between the bow and the string and is defined as

\begin{equation}\label{eq:adhesionMap}
\alpha(v, z) = 
\begin{aligned}
    \begin{cases}
    \begin{rightcases}
        &0 & |z| \leq z_\text{ba}\\
        &\alpha_\text{m}(v,z)&\ \ \ \, z_\text{ba}<|z|<|z_\text{ss}(v)|\\        &1 &|z|\geq|z_\text{ss}(v)|
        \end{rightcases} 
        
        &\text{if}\  \sgn(v)=\sgn(z)\\
        \,0&\!\,\text{if}\  \sgn(v)\neq\sgn(z),
    \end{cases}
    \end{aligned}
\end{equation}
where the transition between the elastic and plastic behaviour is defined as
\begin{equation}\label{eq:alphaM}
    \alpha_\text{m} = \frac{1}{2}\bigg[1+\sgn(z)\sin\bigg(\pi\frac{z-\sgn(z)\frac{1}{2}(|z_\text{ss}(v)|+z_\text{ba})}{|z_\text{ss}(v)|-z_\text{ba}}\bigg)\bigg],
\end{equation}
with break-away displacement $z_\text{ba} = z_\text{ba}(t) = 0.7 f_\text{C}/s_0$ \todo{so is $z_\text{ba} = z_\text{ba}(t)$} determines the value of $z$ before bristles start to break. The adhesion map is visualised in Figure \ref{fig:alphaPlot} and relates to Figure \ref{fig:elastoPlastic} as described in its caption.
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/exciters/drawAlpha3.eps}
    \caption{\label{fig:alphaPlot}A plot of the adhesion map $\alpha(v,z)$ in Eq. \eqref{eq:adhesionMap} plotted against $z$ when $\sgn(v)  = \sgn(z)$. The different coloured regions correspond to Figure \ref{fig:elastoPlastic} according to: yellow - a) \& b), orange - c) and red - d). (Adapted from paper \citeP[C].)}
\end{figure}

\subsubsection{Discrete time}
Equation \eqref{eq:elastoPlasticForce} can be discretised to
\begin{equation}\label{eq:discForceFunction}
    f(v^n,z^n) = s_0z^n + s_1r^n+s_2v^n+s_3w^n
\end{equation} 
where discrete relative velocity in Eq. \eqref{eq:vrelElasto}
\begin{equation}\label{eq:vrelElastoDisc}
    v^n = I(x_\Btxt^n)\dtd\uln - v_\Btxt^n,
\end{equation}
and 
\begin{equation}\label{eq:r}
    r^n = r(v^n,z^n) = v^n\bigg[1-\alpha(v^n,z^n)\frac{z^n}{z_\text{ss}(v^n)}\bigg]
\end{equation}
is the discrete counterpart of \eqref{eq:zdot}. The discrete adhesion map is identical to the continuous definition given in Eqs. \eqref{eq:adhesionMap} and \eqref{eq:alphaM}, but with superscripts $n$ added for appearances of $v$ and $z$.

\subsection{Applied to a FDTD stiff string}
\SWcomment[The first appearance contribution of the PhD project in this dissertation]
The first appearance of a contribution of this work is the elasto-plastic friction model applied to a stiff string implemented using FDTD methods. This has been presented in paper \citeP[C] and will be extended in this section by providing more details on the implementation.\todo{will it though? And should I state the stability stuff here?}

In the same way as done with the static friction model in Section \ref{sec:staticFricMod}, one can add the friction force to the stiff string PDE in Eq. \eqref{eq:stiffStringPDE} and discretise the system as follows:
%
\begin{equation}\label{eq:elastoStiffStringFDS}
    \dtt \uln = c^2 \dxx \uln - \kappa^2 \dxxxx \uln - 2 \sz \dtd \uln + 2 \so\dtm\dxx \uln - J_l(x_\Btxt^n)\frac{f(v^n,z^n)}{\rho A}.
\end{equation}
Following the same procedure as for the static friction model in Section \ref{sec:staticFricMod}, one takes an inner product with $J_l(x_\Btxt^n)$ over discrete string domain $d$ and using identities \eqref{eq:identityIJ} and \eqref{eq:identity1}, one can rewrite this similar to the static friction model in Eq. \eqref{eq:staticFrictionNRfunc} as
%
\begin{equation}
    g_1(v^n,z^n) = \left(\frac{2}{k} + 2\sz\right)v^n + \lVert J_l(x_\Btxt^n)\rVert_d^2\frac{f(v^n,z^n)}{\rho A}+ b^n= 0,
\end{equation}
where
\begin{align*}
    b^n =&-\frac{2}{k}I_l(x_\text{B}^n)\delta_{t-}u_l^n - c^2 I_l(x_\text{B}^n)\delta_{xx} u_l^n +\kappa^2I_l(x_\text{B}^n)\delta_{xxxx} u_l^n\\
    &+\left(\frac{2}{k}+ 2\sigma_0\right)v_\text{B}^n-2\sigma_1I_l(x_\text{B}^n)\delta_{t-}\delta_{xx}u_l^n.
\end{align*}
As $g_1$ contains two unknown variables $v^n$ and $z^n$ that need to be solved for, the multivariate Newton-Raphson method presented in \ref{sec:multivariateNR} must be performed. To be able to do this, an extra function must be included. 

As $r$ describes $\dot z$ in Eq. \eqref{eq:zdot}, one can take another approach to approximate $\dot z$ using the trapezoid rule \cite{theBible}
\begin{equation}
    a^n = (\mtm)^{-1}\dtm z^n \quad \Longrightarrow\quad a^n = \frac{2}{k}(z^n - z^{n-1}) + a^{n-1}.
\end{equation}
As both $a^n$ and $r^n$ approximate $\dot z$ these can be used to create the second function necessary to solve the full system
\begin{equation}
    g_2(v^n, z^n) = r^n - a^n = 0.
\end{equation}

Performing the multivariate Newton-Raphson method described in yields
\begin{equation}\label{eq:NRit}
    \begin{bmatrix}
    v^n\\
    z^n
    \end{bmatrix}_{i+1}
    =
    \begin{bmatrix}
    v^n\\
    z^n
    \end{bmatrix}_i
    -
    \begin{bmatrix}
    \frac{\partial g_1}{\partial v} & \frac{\partial g_1}{\partial z}\\
    \frac{\partial g_2}{\partial v} & \frac{\partial g_2}{\partial z}\\
    \end{bmatrix}^{-1}
    \begin{bmatrix}
    g_1\\
    g_2
    \end{bmatrix}\,
    .
\end{equation}
The derivatives can be shown to be... \SWcomment[should I give those here..? Could have an appendix with derivations haha]

\subsection{Implementation and output}
\SWcomment[still need to write]

\todo{Plots of output and hysteresis loops}

\subsection{Stability through energy analysis}
As the elasto-plastic bow model is a differential equation in itself, its approximation will need to abide a stability condition as well.
As the system at hand is nonlinear, frequency domain analysis as described in Section \ref{sec:stabilityAnalysis} can not be performed. Energy analysis, on the other hand, can be used here to determine the necessary stability condition for this model. This section follows the concepts introduced in Section \ref{sec:stabilityAnalysisEnergy} to obtain a stability conditions for the elasto-plastic friction model. A similar process for finding stability for the LuGre model has been done by Olsson in \cite[p. 55]{Olsson1996} and the derivation below is inspired by his. 

First, all terms of Eq. \eqref{eq:elastoStiffStringFDS} are multiplied by $\rho A$ to get the appropriate units for the analysis. Then, the inner product with $\dtd \uln$ over the string domain $\D$ is taken to get
\begin{equation}
    \dtp \h_\text{s} + \q_\text{s} = -\p_\Btxt
\end{equation}
where the definitions for the discrete Hamiltonian $\h_\text{s}$ and the damping term $\q_\text{s}$ for the string can be found in Section \ref{sec:energyAnalysisString}. The input power introduced by the bow is defined as (writing $f(v^n,z^n) = f^n$)
\begin{equation*}
    \p_\Btxt = \langle (\dtd \uln), J(x_\Btxt^n)f^n\rangle_\D
\end{equation*}
which, using identity \eqref{eq:identityIJ} can be written as 
\begin{equation*}
    \p_\Btxt = I_l(x_\text{B}^n)\dtd \uln f^n.
\end{equation*}
Finally, using Eq. \eqref{eq:vrelElastoDisc} yields
\begin{equation}
    \p_\Btxt = f^nv^n + f^n v_\Btxt^n.
\end{equation}
The term $f^nv^n$ is the important one as $f^nv_\Btxt^n$ is a driving term, and is zero when the external bow velocity is zero. This means that this does not affect the internal stability of the system. In the following, the superscript $n$ is suppressed for clarity.

Substituting Eq. \eqref{eq:discForceFunction} into $fv$ and ignoring the noise term $s_3w^n$ for now, yields
\begin{equation}\label{eq:fv}
    \p_\Btxt = fv = \sigma_{0}zv +\sigma_{1}rv+\sigma_{2}v^2.
\end{equation}
The definition for $r^n$ in Eq. \eqref{eq:r} may be rewritten as
\begin{equation*}
    \begin{aligned}
        r &= v\bigg[1-\alpha\frac{z}{z_\text{ss}(v)}\bigg],\\
        r &= v-\frac{v\alpha z}{z_\text{ss}(v)},\\
        v &= r + \frac{v\alpha z}{z_\text{ss}(v)},
    \end{aligned}
\end{equation*}
and (following Olsson) may be substituted in Eq. \eqref{eq:fv} as
\begin{equation}
    \p_\Btxt = s_{0}z\left(r+ \frac{v\alpha z}{z_\text{ss}(v)}\right)+s_{1}r\left(r+ \frac{v\alpha z}{z_\text{ss}(v)}\right)+s_{2}v^2,
\end{equation}
or
\begin{equation}
    \p_\Btxt = s_0zr+s_1\left(r+\frac{v\alpha z}{2z_\text{ss}(v)}\right)^2+\frac{v\alpha z^2}{z_\text{ss}(v)}\left(s_0-\frac{s_1v\alpha}{4z_\text{ss}(v)}\right)+s_2v^2.
\end{equation}
The power introduced by the bow can then be subdivided into the total energy in the bristles and their damping. As $r$ approximates $\dot z$ the first term, one can rewrite this to 

\SWcomment[NEED TO LOOK AT THE BELOW]
\begin{equation*}
    \dtp \h_\text{brist} = s_0 z^n(\dtd z^n) + \q_\text{brist} \geq 0
\end{equation*}
and needs to be non-negative for passivity. Using identity \eqref{eq:prodIdentity2}
\begin{align*}
    \h_\text{B} &= \frac{s_0}{2} z^ne_{t-}z^n,\\
    & = \frac{s_0}{2}\left((\mtm z^n)^2 - \frac{k^2}{4}(\dtm z^n)^2\right)
\end{align*}
and 
\begin{equation}
    \q_\text{brist} = s_1\left(r+\frac{v\alpha z}{2z_\text{ss}(v)}\right)^2+\frac{v\alpha z^2}{z_\text{ss}(v)}\left(s_0-\frac{s_1v\alpha}{4z_\text{ss}(v)}\right)+s_2v^2.
\end{equation}
Finally, for the system to be passive, $\q$ must be non-negative. As all coefficients are non-negative and $\sgn(v) = \sgn(z_\text{ss}(v))$ (through a multiplication by $\sgn(v)$ in the definition of in Eq. \eqref{eq:zss}) the following must hold
\begin{equation*}
    s_0-\frac{s_1v\alpha}{4z_\text{ss}(v)} \geq 0,\\
\end{equation*}
where both terms are non-negative. Finally, as $\alpha$ is bounded by $1$ the following condition must hold for stability
\begin{equation}
    s_1 \leq \frac{4s_0z_\text{ss}(v)}{v}\ .
\end{equation}
This is the same stability condition as Olsson presents in \cite{Olsson1996}. \SWcomment[So as long as one knows the limit of the velocity of the system, the coefficient $s_1$ can be set accordingly.]