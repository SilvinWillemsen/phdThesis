\chapter{Real-Time Implementation and Control}\label{ch:realtime}

\begin{flushright}{\it
    ``The real problem is that programmers have spent far too much time worrying \\
    about efficiency in the wrong places and at the wrong times; premature\\
    optimization is the root of all evil (or at least most of it) in programming.''\\
    - Donald E. Knuth}
\end{flushright}
%
\vspace{2em}
\noindent A large contribution of this PhD project has been to implement novel combinations of existing FD schemes in real time. As opposed to many FDTD-based musical instruments found in the literature, those presented in this work allow for real-time control such that the virtual instrument can be played. Here, an interactive application is considered real-time when control of the application generates or manipulates audio with no noticeable latency.

For human-computer interaction, the task at hand greatly determines how much latency is acceptable. Wessel and Wright \cite{Wessel2002} place the upper limit of latency when interacting with computers for musical purposes at $10$ ms. Moreover, they place the limit on the \textit{jitter}, the variation of the latency, at $1$ ms. It is thus important to keep the CPU usage at a fixed level as much as possible, and different ways of controlling and interacting with the application should not influence the number of computations much.

Until now, this thesis has made several references to implementations of FD schemes in the \texttt{MATLAB} programming language.
Although \texttt{MATLAB} is a great tool for prototyping, it is a \textit{high-level} programming language (i.e., has a high level of abstraction). Generally, higher-level programming languages are easier to program, but more control -- and speed -- is gained by using a lower-level programming language such as C++.


A great tool for real-time audio programming, which has extensively been used in this project, is the JUCE Framework.\footnote{\url{https://juce.com/}} This framework, written in C++, is specifically developed for programming audio applications and plug-ins. The framework provides the back end of an audio application that handles the audio and graphics threads, and ensures that they can run simultaneously with minimal interference. All real-time physical models that were made over the course of this PhD project have been implemented using the JUCE framework. 

This chapter can be considered as a general contribution that can be applied to all papers in Part \ref{part:papers} (except paper \citeP[G]). Firstly, details on the structure of a class implementing a FD scheme will be provided, using the damped stiff string as an example. Secondly, an overall code structure is given that can be applied to many of the applications created during this PhD project. Finally, this chapter will present the Sensel Morph and the PHANTOM Omni, two hardware devices which have been used to control the physical models presented in papers \citeP[A], \citeP[B], \citeP[C], \citeP[D] and \citeP[E]. Some additional considerations on programming real-time FD schemes can be found in Appendix \ref{app:realTimeConsiderations}.

% Apart from being able to be used by musicians, real-time implementations can truly help to (informally) evaluate the models by interacting with it in a natural way (rather than static parameters).


\section{Real-time FD schemes}\label{sec:realTimeFDScheme}
Until now, this thesis has presented many resonators in matrix form (see e.g. Eqs. \eqref{eq:matrixFormStiffString} and \eqref{eq:matrixFormThinPlate}) for a compact implementation in \texttt{MATLAB}. Although libraries for handling matrices in C++ exist (see e.g. \textit{Eigen} \cite{Eigen}), the highest algorithm speed is obtained by calculating the update equations directly.

In any of the real-time applications created during this project, the update equation implementing a FD scheme is always the most computationally expensive part (given a low refresh-rate for the graphics). This algorithm needs to run at a rate of 44100 Hz, whereas the rest of the implementation can run at a much lower rate. This section provides details and considerations on the real-time implementation of FD schemes in C++ during this project. The damped stiff string presented in Chapter \ref{ch:stiffString} will be used an example. The full implementation can be found online and parts will be presented here to aid the explanation.\footnote{\url{https://github.com/SilvinWillemsen/SimpleStringApp/} (using JUCE v6.0.8)} The FD scheme is implemented in a separate class called \texttt{SimpleString}, and will be used in the following.

% Before going into the implementation of the update equation, this section provides the setup necessary for the implementation.

\subsection{System states and pointer switches}\label{sec:pointerSwitch}
In any FD scheme implementation, at the end of every iteration, the system states must be updated, i.e., the following operations must be performed:
\begin{equation*}
    \u^{n-1} := \u^{n} \qaq \u^{n} := \u^{n+1}.
\end{equation*}
In \texttt{MATLAB}, one would simply perform these operations according to

\setlstMAT
\begin{lstlisting}[belowskip=-0.5\baselineskip]
for n = 1:lengthSound
    ...
    uPrev = u;
    u = uNext;
end
\end{lstlisting}
In C++, however, one has the ability to perform a \textit{pointer switch} to update the system states. For a 1D FD scheme with $N+1$ grid points, the number of copy-operations it takes to update the system states manually would be $2(N+1)$, as shown in Figure \ref{fig:vectorCopy}. A pointer switch, as shown in Figure \ref{fig:pointerSwitch}, only needs 4 copy-operations per iteration and can be carried out in C++ as follows:

\setlstCpp
\begin{lstlisting}[belowskip=-0.5\baselineskip]
double SimpleString::updateStates()
{
    double* uTmp = u[2];
    u[2] = u[1];
    u[1] = u[0];
    u[0] = uTmp;
}
\end{lstlisting}
Here, \texttt{u} is a vector containing 3 pointers, each of which points a state vector at a certain time step: 
\begin{equation*}
    \texttt{u[0]} \rightarrow \u^{n+1}, \quad \texttt{u[1]} \rightarrow \u^{n}, \qaq \texttt{u[2]} \rightarrow \u^{n-1}.
\end{equation*}
A temporary pointer is assigned to the memory location that \texttt{u[2]} points at, to be able to assign that location in memory to \texttt{u[0]} in the end. The values of that vector will be overwritten by the update equation in the next iteration (see Section \ref{sec:updateEquationCpp} and Figure \ref{fig:pointerSwitchFull}).

\begin{figure}[t]
    \centering
    \subfloat[Copying values: $2(N+1)$ operations per iteration. \label{fig:vectorCopy}]{\includegraphics[width=0.8\textwidth]{figures/realtime/vectorCopy.pdf}}\\
    \subfloat[Pointer switch: 4 operations per iteration. \label{fig:pointerSwitch}]{\includegraphics[width=0.8\textwidth]{figures/realtime/pointerSwitch.pdf}}
    \caption{Updating the state vectors by (a) copying all values individually, or (b) performing a pointer switch. Non-zero values are highlighted in green for clarity. The values of the red vector will be overwritten by the update of the scheme in the next iteration.\label{fig:pointerSwitchFull}}
\end{figure}

The state vectors themselves are stored in a matrix (which is a `vector of vectors' in C++). This matrix will have 3 columns related to the 3 time steps required to calculate the FD scheme, and $N+1$ rows, which corresponds to the number of grid points.\footnote{These are not actual rows and columns as in a matrix, but these terms are used here for ease of explanation.} The matrix is initialised as follows

\setlstCpp
\begin{lstlisting}[belowskip=-0.5\baselineskip]
//// In the constructor of SimpleString ////

// initialise vectors
uStates = std::vector<std::vector<double>> (3, 
                                    std::vector<double>(N+1, 0));
\end{lstlisting}
%
Next, the aforementioned pointers are initialised such that they contain the memory addresses of the start of the three state vectors in the matrix.
\\
\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}[belowskip=-0.5\baselineskip]
//// In the constructor of SimpleString ////

// Initialise pointer vector
u.resize (3, nullptr);

// Make set memory addresses to first index of the state vectors.
for (int i = 0; i < 3; ++i)
    u[i] = &uStates[i][0];
\end{lstlisting}
\end{minipage}
One will then be able to work with the pointers directly in the eventual update equation (see Section \ref{sec:updateEquationCpp}).
    
\subsection{Pre-calculation of coefficients}
To prevent extra computations in the FD scheme, it is useful to calculate as many of the coefficients as possible beforehand (provided that these do not vary over time). Recalling the update equation for a stiff string in Eq. \eqref{eq:stiffStringUpdate}, one can write this as
\begin{equation}
    \begin{aligned}
        A_\text{div} u_l^{n+1} &= B_1 \uln + B_2 (u_{l+1}^n + u_{l-1}^n) + B_3(u_{l+2}^n + u_{l-2}^n) \\
        &\quad+ C_1u_l^{n-1}+ C_2(u_{l+1}^{n-1} + u_{l-1}^{n-1}),
    \end{aligned}
    \end{equation}
where
\begin{gather*}
    A_\text{div} = 1+\sz k, \quad B_0 = 2 - 2\lambda^2 - 6\mu^2 - \frac{4\so k}{h^2}, \quad B_1 = \lambda^2 + 4\mu^2 + \frac{2\so k}{h^2},\\
    B_2 = - \mu^2, \quad C_0 = -1+\sz k + \frac{4\so k}{h^2},\qaq C_1 = - \frac{2\so k}{h^2}.
\end{gather*}
All of these coefficients can be calculated in the constructor of the stiff string class. One can also already divide the $B$ and $C$ coefficients by $A_\text{div}$ as done in the code below.
\setlstCpp
\begin{lstlisting}[]
//// In the constructor of SimpleString ////

// Coefficients used for damping
S0 = sigma0 * k;
S1 = (2.0 * sigma1 * k) / (h * h);

// Scheme coefficients
B0 = 2.0 - 2.0 * lambdaSq - 6.0 * muSq - 2.0 * S1; // u_l^n
B1 = lambdaSq + 4.0 * muSq + S1;                   // u_{l+-1}^n
B2 = -muSq;                                        // u_{l+-2}^n
C0 = -1.0 + S1 + 2.0 * S2;                         // u_l^{n-1}
C1 = -S1;                                          // u_{l+-1}^{n-1}

Adiv = 1.0 / (1.0 + S0);                           // u_l^{n+1}

// Divide by u_l^{n+1} term
B0 *= Adiv;
B1 *= Adiv;
B2 *= Adiv;
C0 *= Adiv;
C1 *= Adiv;
\end{lstlisting}
\pagebreak
\subsection{Update equation}\label{sec:updateEquationCpp}
With all the above set up, the update equation can be implemented as follows:

\begin{lstlisting}[belowskip=-0.5\baselineskip]
void SimpleString::calculateScheme()
{
    for (int l = 2; l < N-1; ++l) // clamped boundaries
        u[0][l] = B1 * u[1][l] + B2 * (u[1][l + 1] + u[1][l - 1]) 
            + B3 * (u[1][l + 2] + u[1][l - 2])         
            + C1 * u[2][l] + C2 * (u[2][l + 1] + u[2][l - 1]);
}
\end{lstlisting}
This function and the pointer switch in Section \ref{sec:pointerSwitch} (in that order) will then have to be called once per sample.

\subsection{Acceleration strategies}
Apart from implementing the physical models in C++ rather than \texttt{MATLAB}, additional acceleration strategies can be used for even faster algorithms. FD schemes, especially explicit schemes, are highly parallelisable, i.e., many of the operations done are identical and can run simultaneously. A great overview is given in \cite{Bilbao2019CMJb} and provides advantages and disadvantages of using the GPU, multicore processing and vector instructions (SIMD, AVX). An in-depth evaluation of FD schemes (both 1D and 2D), implemented using multicore processing and AVX instructions, has been carried out in \cite{Webb2015}.

For this project, none of these acceleration strategies have been used, but could be investigated in the future. Occasionally, the quality of 2D systems has been lowered to allow for a real-time implementation (see papers \citeP[A] and \citeP[D]). However, as strings were used as the main resonators of many of the implementations, these decreases in quality were deemed unimportant for the eventual output sound of the simulation.

\section{Code structure}\label{sec:codeStructure}
This section presents the general code structure used for the real-time applications created in this project. As an example, consider a simple instrument consisting of one string and one plate, and a connection between them as presented in Section \ref{sec:stringPlateConnection}. The string is excited using the Sensel Morph (see Section \ref{sec:sensel}). This is a simplified case of the contribution made in papers \citeP[A] and \citeP[B]. 

The structure of the code is visualised in Figure \ref{fig:codeStructure}. The white boxes denote various classes or components of the application, which will be described in detail shortly. The black arrows indicate instructions, and hollow arrows indicate data flows. All arrows are accompanied by a box denoting the type of instruction / dataflow and the colour of the box denotes at what rate this happens.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/realtime/flowchart.pdf}
    \caption{The structure of a real-time implementation of a physical model. Boxes with `u \& o' refer to `update and output' and `Inter.' is short for `Interaction'. A detailed description of the figure is given in Section \ref{sec:codeStructure}.\label{fig:codeStructure}}
\end{figure}

\subsubsection{Threads}
The application contains three different threads, all handled by the JUCE back end. The highest priority thread is the audio thread, which is denoted by orange blocks. It runs at 44100 Hz and handles the calculations of the FD schemes. Denoted by blue, is the control thread, which runs at 150 Hz. The input from the Sensel will be applied to the application at this rate. This rate corresponds to a maximum control latency of \textApprox 7 ms, which is below the upper limit for latency in musical applications proposed in \cite{Wessel2002}. Finally, the thread updating the graphical user interface (GUI) is set to run at 15 Hz, which is a value that was heuristically found to be a good balance between good visuals and a fast application. %For powerful computers, or for low-complexity physical models, the speed could be increased. 
Papers \citeP[A], \citeP[C], and \citeP[H], contain a comparison between the speed of the application with and without the graphics. In all cases, results showed that the graphics take up a large part of the computational power available.

\subsubsection{String and Plate}
The String and Plate classes implement the FD schemes of the stiff string and thin plate resonators respectively.\footnote{Note that the class can not actually be called `String' as this is already an existing variable type.} See Section \ref{sec:realTimeFDScheme} for an example of an implementation of the stiff string; a similar code structure can be used for the Plate class. As this section follows Section \ref{sec:stringPlateConnection}, the states of the string and the plate will be denoted by $u$ and $w$, respectively. 

For the resonators to work in isolation, both classes require a function that calculates the scheme, and a function that updates their system states (see Section \ref{sec:realTimeFDScheme}). The interactions between the classes is handled by the Instrument class (see below). Therefore, both classes require additional functions that return $u^\star$ and $w^\star$, as well as a function that adds the interaction force $f^n$ to the schemes. A final function returns the output of the resonators.

Lastly, the classes contain a \texttt{paint} function which is used to draw the state of the system on the screen. This function is called by the JUCE back end at the rate that the graphics thread is set to.

\subsubsection{Instrument}
The Instrument class contains instances of the individual String and Plate resonators. Rather than performing the calculations of the FD schemes, the Instrument class handles all interactions between the individual resonators. In Figure \ref{fig:codeStructure}, this is denoted by the `Inter.' block and it follows a similar process to Section \ref{sec:implementationStringPlate} (albeit not in matrix-vector form):
\begin{enumerate}
    \item The Instrument class instructs the resonators to calculate their respective schemes without the connection force (Eq. \eqref{eq:stringPlateImp1}).
    \item The intermediate states at the connection location, $u^\star$ and $w^\star$, are retrieved (Eq. \eqref{eq:stringPlateImp2}).
    \item The connection force $f^n$ is calculated using Eq. \eqref{eq:stringPlateForce}.
    \item The force is added to the scheme (Eq. \eqref{eq:stringPlateImp4}).
\end{enumerate}

\subsubsection{Main Application and Control}
The Main Application (also called \texttt{MainComponent} in JUCE), is the top-level class of the application that handles control input and audio and graphics output.\footnote{This section assumes that the JUCE Audio Application template has been chosen -- not the Audio Plug-in template.} The Main Application contains an instance of the Instrument class and instructs it to calculate the schemes and their interactions once per sample. Furthermore, it retrieves the output from the Instrument and sends this to the audio device at the same rate.

Finally, the application is controlled by the Sensel Morph. The Main Application checks the state of the Sensel at a rate of 150 Hz and maps this to control parameters used by the scheme.

% \section{Optimisation strategies}
% This section provides several optimisation strategies that can be used for faster implementations. Although not all of these have not been used



% \subsection{Code}
% Much optimisation can already be done in the code itself 


% \subsubsection{Grouping terms and precalculating coefficients}
% Generally in implementations of FD schemes the most computationally expensive part of the algorithm is the calculation of the scheme itself. This is due to the rate at which it needs to be updated which usually is 44100 Hz. Graphics can be updated at rates orders of magnitude lower than the audio (\textApprox 60 Hz) and still be considered smooth enough.

% Recall the update equation for the 1D wave update equation in Eq. \eqref{eq:1DwaveUpdate}
% \begin{equation*}
%     u_l^{n+1} = (2 - 2 \lambda^2) \uln - u_l^{n-1} + \lambda^2\left(u_{l+1}^n + u_{l-1}^n\right).
% \end{equation*}
% Grouping the terms like this allows for the coefficients multiplied onto the grid function at different temporal and spatial indices to be precomputed. This can significantly decrease the number of operations per sample.

% The undamped stiff string FD scheme%in \eqref{eq:stiffStringFDS}
% \begin{equation}
%     \dtt \uln = c^2 \dxx \uln - \kappa^2 \dxxxx \uln,
% \end{equation}
% can be expanded to an update equation as
% \begin{equation}
%     \begin{aligned}
%         u_l^{n+1} = &\ 2\uln - u_l^{n-1} + \lambda^2 \left(u_{l+1}^n - 2\uln + u_{l-1}^n\right)\\
%         & - \mu^2 \left(u_{l+2}^n - 4u_{l+1}^n + 6\uln + -4u_{l-1}^n + u_{l-2}^n\right)
%     \end{aligned}
% \end{equation}
% where $\lambda = ck/h$ and $\mu = \kappa k / h^2$.

% For implementation purposes there is a better way to write this scheme that reduces the number of computations. This is done by collecting the terms based on the grid function and pre-calculating the coefficients multiplied onto these. As the schemes are spatially symmetric, ``neighbouring points'' relative to $\uln$ can also be grouped to get
% \def\semilarge{\fontsize{11}{11.6}\selectfont}
% \begin{equation}
%     u_l^{n+1} = \underbrace{(2 - 2\lambda^2 - 6\mu^2)}_{\texttt{\semilarge B1}}\uln  + \underbrace{\left(\lambda^2 + 4\mu^2\right)}_{\texttt{\semilarge B2}}\left(u_{l+1}^n+u_{l-1}^n\right)\underbrace{-\mu^2}_{\texttt{\semilarge B3}} \left(u_{l+2}^n+u_{l-2}^n\right) \underbrace{-}_{\texttt{\semilarge C1}} u_l^{n-1}.
% \end{equation}
% These coefficients can then be pre-calculated and do not have to be 






% \section{Matrices}\label{sec:realTimeMatrices}

% Library called \textit{Eigen} \cite{Eigen}

% \subsection{Matrix inversions in real-time}\label{sec:RTmatrixInversion}
% For small ($2\times 2$ and $3\times 3$) matrices it is doable to do the inversion `by hand'. This requires finding the \textit{determinant} of a matrix

% \begin{equation*}
%     \u = \A^{-1}\w, 
% \end{equation*}
% where
% \begin{equation}
%     \A^{-1} = \frac{1}{a_{00}\cdot a_{11} - a_{01}\cdot a_{10}}
%     \begin{bmatrix}
%         a_{11} & -a_{01}\\
%         -a_{10} & a_{00} 
%     \end{bmatrix}
% \end{equation}

% \setlstCpp
% \begin{lstlisting}
% det = a00 * a11 - a01 * a10;
% u0 = (w0 * a11 - w1 * a01) / det;
% u1 = (-w0 * a10 + w1 * a00) / det;
% \end{lstlisting}


% The computational complexity of th inversion of an $n\times n$ matrix is (at worst) $\OO(n^3)$. For real-time applications, the size of matrices one wants to invert thus need to be kept to a minimum...

% The difference between inverting a $2\times 2$ matrix and a $3\times 3$ 

\section{Hardware devices}
Throughout this project, two hardware devices to expressively control the simulated instruments have been investigated. These are the Sensel Morph and the PHANTOM Omni, both of which will be briefly described here. The mapping of these controllers to the various instrument simulations can be found in the respective papers described below. 

\subsection{Sensel Morph}\label{sec:sensel}
The \textit{Sensel Morph,} or Sensel for short, is a high-accuracy pressure sensitive touch controller, containing \textApprox 20,000 pressure-sensitive sensors that allow for high-fidelity control (see Figure \ref{fig:sensel}) \cite{sensel}. Above the touch-sensitive area, the controller contains an array of 24 LEDs that can be programmed and used to provide information to the user.

Papers \citeP[A] and \citeP[B] were the first scientific papers to use the Sensel to control a musical instrument simulation. Afterwards, the controller was used for other applications in the Sound and Music Computing field \cite{Paisa2019,Pardue2020,vanWalstijn2021}. 

For this project, the Sensel has mainly been used to control the bow to excite stiff strings in papers \citeP[A], \citeP[B], \citeP[C] and \citeP[D]. Additionally, it is used to excite strings using simple pluck and hammer excitations as described in Section \ref{sec:timeVaryingExcitations}. Details on the mapping of the Sensel to the various implementations can be found in the respective papers.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/contributions/realtime/senselHands.jpg}
    \caption{The Sensel Morph. \label{fig:sensel}}
\end{figure}


\subsection{PHANTOM Omni}\label{sec:phantomOmni}
The PHANTOM Omni, or Omni for short, by SenseAble Technologies (now 3D Systems), is a six-degrees-of-freedom (6-DoF) device that provides force and vibrotactile feedback (see Figure \ref{fig:omni}) \cite{OmniAPI2018}. Moreover, it allows for highly accurate tracking in a 3D application, and has been used in paper \citeP[E] to control the bow of the tromba marina. 

Other work using the Omni in a musical context, specifically for plucking a virtual guitar string, was done by Passalenti et al. in \cite{passalenti2019a, passalenti2019b} and Fontana et al. in \cite{Fontana2020}.

\begin{figure}[h]\includegraphics[width=0.8\textwidth]{figures/contributions/realtime/omniSchematic.png}
    \centering
      \caption{The PHANTOM Omni haptic device. The device has six axes of rotation (6-DoF), three of which provide force feedback (A1-3), and three that only track position (B1-3). (Adapted from paper \citeP[E].) \label{fig:omni}}
\end{figure}